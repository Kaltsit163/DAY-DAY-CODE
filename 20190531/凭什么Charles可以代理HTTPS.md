### 1. HTTPS 是个啥？

------
就是建立在HTTP之上的一层东西，不是新的协议，是套在HTTP外层的，好吧，我编不下去了；
其实就是，在HTTP通信之前，先建立SSL/TLS通信，双方协商一个通讯密钥，然后使用这个通信密钥加密HTTP通信，简而言之就是这个；

-----

### 2. SSL/TLS 如何握手
1. 第一个步骤
   1.  + 发送方: 客户端
       + 接受方: 服务端
       + 荷载: 客户端支持的SSL版本、加密组件（加密方法、压缩方法、密钥长度，随机数R1）等
       + 做了啥：发送client hello 给服务端
   2.  + 发送方: 服务端
       + 接受方: 客户端
       + 荷载: SSL版本、加密组件、随机数R2
       + 做了啥：发送server hello 给客户端
   3.  + 发送方: 服务端
       + 接受方: 客户端
       + 荷载: SSL版本、加密组件、随机数R2
       + 做了啥：发送server hello 给客户端
   4.  + 发送方: 服务端
       + 接受方: 客户端
       + 荷载: 发送CA证书（内置公钥）
       + 做了啥：发送server hello 给客户端
   5.  + 发送方: 服务端
       + 接受方: 客户端
       + 荷载: server hello done
       + 做了啥：通知客户端，首次SSL握手结束
---
2. 第二个步
   1.  + 发送方: 客户端
       + 接受方: 服务端
       + 荷载:  使用公钥加密后的（随机数R3-pre-master-key）
       + 做了啥：验证公钥确实有效，发送 client key exchange；
   2.  + 发送方: 客户端
       + 接受方: 服务端
       + 荷载: change cipher spec；
       + 做了啥：通知服务器后续，会以 pre-master-key 来加密，编码变更； 
   3.  + 发送方: 客户端
       + 接受方: 服务端
       + 荷载: 至今所有随机hash数，整体校验值
       + 做了啥：发送 finished 报文，这次握手能否成功，要以服务器能否正确解密这个报文作为判断标准；
---
3. 第三个步骤
   1.  + 发送方: 服务端
       + 接受方: 客户端
       + 荷载: change cipher sepc
       + 做了啥：确认收到编码改变信息，服务器后续也会使用商议好的编码进行
   2.  + 发送方: 服务端
       + 接受方: 客户端
       + 荷载: 至今所有随机hash数，整体校验值
       + 做了啥：发送 finished，SSL建立完毕
---
4. 第四个步骤
  + HTTP 通信
  + 客户端断开链接，发送close_notify
  + TCP FIN 报文关闭 TCP 通信

### 3. 如何验证证书有效？

上文说到，在客户端收到服务端的返回之后，其实会有一个校验证书的过程，那么是如何去校验证书的呢？

<img src="https://images2018.cnblogs.com/blog/1276550/201808/1276550-20180818111007025-358791682.png">

+ 服务器运营者申请数字证书：
    ```javascript
    申请->确认身份->对申请的公开密匙做数字签名->分配这个签名的公开密匙，并将密匙和证书绑定。

    服务器把公钥和证书发给客户端。
    客户端用数字证书认证机构的公开密匙对证书上的数字签名进行验证。
    一旦验证通过，客户端即可安全的使用服务器的公开密匙了。
    ⚠️： 多数浏览器内部会有常用认证机构的公开密匙。
    ```
----

    1·首先浏览器都会内置一些证书公司的公钥
    2.服务器会将自己的公钥和信息，提供给证书公司，证书公司会用自己的私钥将其信息加密，


### 4. 既让这样，Charles 是如何做到 https 代理的呢？

归根究底，还是Charles 做了一个中间代理，并且你还信任了Charles，详细步骤看下面；

+ 客户端向服务器发起HTTPS请求
+ Charles拦截客户端的请求，伪装成客户端向服务器进行请求
+ 服务器向“客户端”（实际上是Charles）返回服务器的CA证书
+ Charles拦截服务器的响应，获取服务器证书公钥，然后自己制作一张证书，将服务器证书替换后发给客户端。（这一步，Charles拿到了服务器证书的公钥）
+ 客户端接收到“服务器”（实际上是Charles）的证书后，会验证，如果你不信任，安装Charles的证书，这里就无法通过信任，代理失败，安装以后，客户端会生成一个对称密钥，用Charles的公钥加密，发送给“服务器”（Charles）
+ Charles拦截客户端的响应，用自己的私钥解密对称密钥，然后用服务器证书公钥加密，发送给服务器。（这一步，Charles拿到了对称密钥）
+ 服务器用自己的私钥解密对称密钥，向“客户端”（Charles）发送响应
+ Charles拦截服务器的响应，替换成自己的证书后发送给客户端
+ 至此，连接建立，Charles拿到了 服务器证书的公钥 和 客户端与服务器协商的对称密钥，之后就可以解密或者修改加密的报文了。
