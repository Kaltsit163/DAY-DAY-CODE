先日常抛出一段话，你想想对不对；

<code>
  对于基础类型，数据本身是存在栈内，对于复杂类型，在栈中存的只是一个堆内地址的引用。
</code>

那么问题来了，“如果说原始类型存在在栈中，那么 JavaScript 中的闭包是如何实现的？”

### 栈

---
```javscript
  function Sum () {
    let i = 1;
    let j = 2;
    return i + j;
  }
```
---
![pic](https://dpubstatic.udache.com/static/dpubimg/a47275af-2a7b-4218-895b-a75373b258b7.png)

1. 栈是内存中一块用于存储局部变量和函数参数的线性结构，遵循着先进后出的原则。数据只能顺序的入栈，顺序的出栈。当然，栈只是内存中一片连续区域一种形式化的描述，数据入栈和出栈的操作仅仅是栈指针在内存地址上的上下移动而已。
2. 因此栈的特点：轻量，不需要手动管理，函数调时创建，调用结束则消失。
3. 内存中栈区的数据，在函数调用结束后，就会自动的出栈，不需要程序进行操作，操作系统会自动执行，换句话说：栈中的变量在函数调用结束后，就会消失，仅仅是把栈指针往下移动而已，并不是真正的数据弹出，数据还在，只不过下次赋值时会被覆盖；

---

### 堆

---

### 问题

既然栈中数据在函数执行结束后就会被销毁，那么 JavaScript 中函数闭包该如何实现，先简单来个闭包：

```javscript
  function count () {
    let num = -1;
    return function () {
      num++;
      return num;
    }
  }

  let numCount = count();
  numCount();
  // 0
  numCount();
  // 1
```