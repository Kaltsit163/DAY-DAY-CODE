V8 GC

1. 方法：

主要还是基于分代的GC机制，根据对象存活的时间，然后对不同的分代采用不同的垃圾回收算法；

2. V8 内存结构

其实除了新/老（指针 + 数据）生带，其实还有别的区域，大对象区，代码区，Map区；

3. 新生代中的流程步骤

  新生代里面，主要存放存活时间比较短的对象，并且由两个 semispace 半空间构成，主要采用 scavenge 算法；
将内存一分为二，在GC时，先把还存活的对象（还在被引用），复制到另一半里面，复制完成之后，再一下子清空掉原有的一半空间；
这么一个腾挪的过程，牺牲空间换时间

4. 新对象是如何变成老生代的呢？

经过这个腾挪的过程，并且新的空间里面，内存占比已经到了25% 了；

5. 老生代中的流程步骤
  管理大量存活的对象，采用的是 mark-sweep 和 mark-compact 模式进行管理；

Mark-Sweep(标记清除)分为标记和清除两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。Mark-Sweep算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收，具体步骤如下：

  垃圾回收器会在内部构建一个根列表，用于从根节点出发去寻找那些可以被访问到的变量。比如在JavaScript中，window全局对象可以看成一个根节点。
然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。
最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。

  但是Mark-Sweep算法存在一个问题，就是在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现内存碎片的问题，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。
为了解决这种内存碎片的问题，Mark-Compact(标记整理)算法被提了出来，该算法主要就是用来解决内存的碎片化问题的，回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存。

  
6. 执行时机

JS单线程，GC 也会阻塞，V8 有一个增量标记，先标记，再处理，有点类似 fiber

7. 怎么避免内存泄漏

全局变量
手动清除定时器
少用闭包
清除DOM引用


