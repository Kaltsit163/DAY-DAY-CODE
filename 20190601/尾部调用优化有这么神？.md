一、什么是尾调用？

1. 就是指某个函数的最后一步是调用另一个函数，在某些地方有优化奇效；

    ----
    看看，这个就是一个真正的典型的尾部调用，
    ```javascript
    function f(x){
        return g(x);
    }
    ```
    下面都是虚伪的尾部调用
    ```javascript
    // 情况一
    function f(x){
        let y = g(x);
        return y;
    }
    // 执行g(x)后，获取返回结果，还需要赋值给y，再返回y

    // 情况二
    function f(x){
        return g(x) + 3;
    }
    // 执行g(x)后，获取返回结果后，还需要计算 + 1，再返回这个计算值
    ```

    上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。

    ```javascript
    // 情况一
    function f(x){
        if (!x) {
            return g(x);
        }
        return l(x);
    }
    // 尾调用不一定出现在函数尾部，只要是最后一步操作即可；
    ```

2. 尾调用优化

尾调用之所以与其他调用不同，就在于它的特殊的调用位置。

我们知道，函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个"调用栈"（call stack）。

<img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015041002.png">

----

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。

### 所以说了这么久，到底有什么用！我们来看看

```javascript
// 熟悉的斐波那契数列
function fib(n) {
    if(n===1 || n===2){
        return 1;
    }
    return fib(n-1) + fib(n-2);
}

fib(5) // 120
fib(999) // 试试就逝世
```

每一个我们进行递归，就会有一个"递归帧"压如栈空间，
如A函数递归调用B函数，那么A函数的递归帧会压栈，直到B函数释放栈空间；
递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生"栈溢出"错误（stack overflow）。

```javascript
// 还是熟悉的斐波那契数列
function fib2 (n, ca1 = 1, ca2 = 1){
    if(n === 1 || n === 2){
        return ca2;
    }
    return fib2(n-1, ca2, ca1 + ca2);
}
```
但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误。
这就叫做"尾调用优化"（Tail call optimization），
、即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。



